# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zi5Q6jqR22GtIKaXDFd_a5RWW7xTo3Ow
"""

import csv
import datetime as dt
import json
import os
import re
import urllib.request
from concurrent.futures import ThreadPoolExecutor
from pathlib import Path
from typing import Any, Dict, List, Optional

METASTORE_URL = "https://data.cms.gov/provider-data/api/1/metastore/schemas/dataset/items"
THEME = "Hospitals"
DATA_DIR = Path("data")
META_FILE = Path("run_metadata.json")



def load_last_run() -> Optional[dt.datetime]:

    if META_FILE.exists():
        with META_FILE.open("r", encoding="utf-8") as f:
            meta = json.load(f)
        try:
            return dt.datetime.fromisoformat(meta["last_run"])
        except (KeyError, ValueError):
            return None
    return None


def save_last_run(ts: dt.datetime) -> None:

    with META_FILE.open("w", encoding="utf-8") as f:
        json.dump({"last_run": ts.isoformat()}, f)

def http_get_json(url: str) -> Any:
    with urllib.request.urlopen(url) as resp:
        return json.loads(resp.read().decode("utf-8"))


def to_snake_case(name: str) -> str:
    name = name.strip().lower()
    name = re.sub(r"[^a-z0-9]+", "_", name)
    name = re.sub(r"_+", "_", name)
    return name.strip("_")


def get_modified_raw(item: Dict[str, Any]) -> Optional[str]:
    for key in ("modified", "modified_date", "lastModified"):
        if key in item:
            return item[key]
    return None


def parse_modified(item: Dict[str, Any]) -> Optional[dt.datetime]:
    raw = get_modified_raw(item)
    if not raw:
        return None
    for fmt in ("%Y-%m-%dT%H:%M:%S.%fZ",
                "%Y-%m-%dT%H:%M:%SZ",
                "%Y-%m-%d"):
        try:
            return dt.datetime.strptime(raw, fmt)
        except ValueError:
            continue
    return None


def get_download_url(item: Dict[str, Any]) -> Optional[str]:
    if "distribution" in item and item["distribution"]:
        dist = item["distribution"][0]
        return dist.get("downloadURL") or dist.get("accessURL")
    return item.get("downloadURL")


def is_hospitals_theme(item: Dict[str, Any]) -> bool:
    themes = item.get("theme") or item.get("themes") or []
    if isinstance(themes, str):
        themes = [themes]
    return any(THEME.lower() in t.lower() for t in themes)


def normalize_csv_headers(path: Path) -> None:

    with path.open("r", newline="", encoding="utf-8") as f:
        reader = csv.reader(f)
        rows: List[List[str]] = list(reader)

    if not rows:
        return

    rows[0] = [to_snake_case(h) for h in rows[0]]

    with path.open("w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerows(rows)


def download_dataset(item: Dict[str, Any]) -> None:

    url = get_download_url(item)
    if not url:
        print(f"Skipping dataset with no download URL: {item.get('identifier')}")
        return

    identifier = item.get("identifier") or item.get("title", "dataset")
    filename = f"{to_snake_case(identifier)}.csv"
    out_path = DATA_DIR / filename

    print(f"Downloading {identifier} from {url}")
    with urllib.request.urlopen(url) as resp, out_path.open("wb") as f:
        f.write(resp.read())

    normalize_csv_headers(out_path)
    print(f"Saved and normalized: {out_path}")




def main() -> None:
    DATA_DIR.mkdir(exist_ok=True)

    last_run = load_last_run()
    now = dt.datetime.utcnow()

    items = http_get_json(METASTORE_URL)

    if isinstance(items, dict) and "items" in items:
        items = items["items"]

    to_download: List[Dict[str, Any]] = []
    for item in items:
        if not is_hospitals_theme(item):
            continue

        modified = parse_modified(item)
        if last_run and modified and modified <= last_run:

            continue

        to_download.append(item)

    print(f"Datasets to download: {len(to_download)}")

    with ThreadPoolExecutor(max_workers=4) as pool:
        pool.map(download_dataset, to_download)

    save_last_run(now)


if __name__ == "__main__":
    main()